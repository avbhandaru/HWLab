package edu.cornell.cs3410;

import java.util.Arrays;

class MemContentsSub
{
  static ContentsInterface createContents(int paramInt1, int paramInt2)
  {
    if (paramInt2 <= 8) {
      return new ByteContents(paramInt1);
    }
    if (paramInt2 <= 16) {
      return new ShortContents(paramInt1);
    }
    return new IntContents(paramInt1);
  }
  
  private static class IntContents
    extends MemContentsSub.ContentsInterface
  {
    private int[] data;
    
    public IntContents(int paramInt)
    {
      this.data = new int[paramInt];
    }
    
    public IntContents clone()
    {
      IntContents localIntContents = (IntContents)super.clone();
      localIntContents.data = new int[this.data.length];
      System.arraycopy(this.data, 0, localIntContents.data, 0, this.data.length);
      return localIntContents;
    }
    
    int getLength()
    {
      return this.data.length;
    }
    
    int get(int paramInt)
    {
      return (paramInt >= 0) && (paramInt < this.data.length) ? this.data[paramInt] : 0;
    }
    
    void set(int paramInt1, int paramInt2)
    {
      if ((paramInt1 >= 0) && (paramInt1 < this.data.length))
      {
        int i = this.data[paramInt1];
        if (paramInt2 != i) {
          this.data[paramInt1] = paramInt2;
        }
      }
    }
    
    void clear()
    {
      Arrays.fill(this.data, 0);
    }
    
    void load(int paramInt1, int[] paramArrayOfInt, int paramInt2)
    {
      int i = Math.min(paramArrayOfInt.length, this.data.length - paramInt1);
      for (int j = 0; j < i; j++) {
        this.data[j] = (paramArrayOfInt[j] & paramInt2);
      }
    }
  }
  
  private static class ShortContents
    extends MemContentsSub.ContentsInterface
  {
    private short[] data;
    
    public ShortContents(int paramInt)
    {
      this.data = new short[paramInt];
    }
    
    public ShortContents clone()
    {
      ShortContents localShortContents = (ShortContents)super.clone();
      localShortContents.data = new short[this.data.length];
      System.arraycopy(this.data, 0, localShortContents.data, 0, this.data.length);
      return localShortContents;
    }
    
    int getLength()
    {
      return this.data.length;
    }
    
    int get(int paramInt)
    {
      return (paramInt >= 0) && (paramInt < this.data.length) ? this.data[paramInt] : 0;
    }
    
    void set(int paramInt1, int paramInt2)
    {
      if ((paramInt1 >= 0) && (paramInt1 < this.data.length))
      {
        int i = this.data[paramInt1];
        if (paramInt2 != i) {
          this.data[paramInt1] = ((short)paramInt2);
        }
      }
    }
    
    void clear()
    {
      Arrays.fill(this.data, (short)0);
    }
    
    void load(int paramInt1, int[] paramArrayOfInt, int paramInt2)
    {
      int i = Math.min(paramArrayOfInt.length, this.data.length - paramInt1);
      for (int j = 0; j < i; j++) {
        this.data[(paramInt1 + j)] = ((short)(paramArrayOfInt[j] & paramInt2));
      }
    }
  }
  
  private static class ByteContents
    extends MemContentsSub.ContentsInterface
  {
    private byte[] data;
    
    public ByteContents(int paramInt)
    {
      this.data = new byte[paramInt];
    }
    
    public ByteContents clone()
    {
      ByteContents localByteContents = (ByteContents)super.clone();
      localByteContents.data = new byte[this.data.length];
      System.arraycopy(this.data, 0, localByteContents.data, 0, this.data.length);
      return localByteContents;
    }
    
    int getLength()
    {
      return this.data.length;
    }
    
    int get(int paramInt)
    {
      return (paramInt >= 0) && (paramInt < this.data.length) ? this.data[paramInt] : 0;
    }
    
    void set(int paramInt1, int paramInt2)
    {
      if ((paramInt1 >= 0) && (paramInt1 < this.data.length))
      {
        int i = this.data[paramInt1];
        if (paramInt2 != i) {
          this.data[paramInt1] = ((byte)paramInt2);
        }
      }
    }
    
    void clear()
    {
      Arrays.fill(this.data, (byte)0);
    }
    
    void load(int paramInt1, int[] paramArrayOfInt, int paramInt2)
    {
      int i = Math.min(paramArrayOfInt.length, this.data.length - paramInt1);
      for (int j = 0; j < i; j++) {
        this.data[(paramInt1 + j)] = ((byte)(paramArrayOfInt[j] & paramInt2));
      }
    }
  }
  
  static abstract class ContentsInterface
    implements Cloneable
  {
    public ContentsInterface clone()
    {
      try
      {
        return (ContentsInterface)super.clone();
      }
      catch (CloneNotSupportedException localCloneNotSupportedException) {}
      return this;
    }
    
    abstract int getLength();
    
    abstract int get(int paramInt);
    
    abstract void set(int paramInt1, int paramInt2);
    
    abstract void clear();
    
    abstract void load(int paramInt1, int[] paramArrayOfInt, int paramInt2);
    
    boolean matches(int[] paramArrayOfInt, int paramInt1, int paramInt2)
    {
      for (int i = 0; i < paramArrayOfInt.length; i++) {
        if (get(paramInt1 + i) != (paramArrayOfInt[i] & paramInt2)) {
          return false;
        }
      }
      return true;
    }
    
    int[] get(int paramInt1, int paramInt2)
    {
      int[] arrayOfInt = new int[paramInt2];
      for (int i = 0; i < arrayOfInt.length; i++) {
        arrayOfInt[i] = get(paramInt1 + i);
      }
      return arrayOfInt;
    }
    
    boolean isClear()
    {
      int i = 0;
      int j = getLength();
      while (i < j)
      {
        if (get(i) != 0) {
          return false;
        }
        i++;
      }
      return true;
    }
  }
}
