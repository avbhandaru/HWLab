package edu.cornell.cs3410;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ProgramAssembler
{
  private static final int NO_OP = 0;
  private static Pattern pat0 = Pattern.compile("\\s+");
  private static Pattern pat1 = Pattern.compile("\\s*,\\s*");
  static String _reg = "\\$(\\d+|zero|at|v[01]|a[0-3]|t[0-9]|s[0-7]|k[01]|gp|sp|fp|ra)";
  static String __hex = "0x[a-fA-F0-9]+";
  static String __decimal = "-?\\d+";
  static String __label = "[a-zA-Z]\\w*";
  static String _imm = "(" + __hex + "|" + __decimal + "|" + __label + ")";
  static Pattern pat_label = Pattern.compile("(" + __label + ")");
  static HashMap<String, Command> cmds = new HashMap();
  static HashMap<Integer, Command> opcodes = new HashMap();
  static HashMap<Integer, Command> fcodes = new HashMap();
  static HashMap<Integer, Command> socodes = new HashMap();
  static Pattern pat_word = Pattern.compile(_imm);
  static Pattern pat_arith_imm = Pattern.compile(_reg + "," + _reg + "," + _imm);
  static Pattern pat_lui = Pattern.compile(_reg + "," + _imm);
  static Pattern pat_mem = Pattern.compile(_reg + "," + _imm + "\\(" + _reg + "\\)");
  static Pattern pat_br = Pattern.compile(_reg + "," + _reg + "," + _imm);
  static Pattern pat_bz = Pattern.compile(_reg + "," + _imm);
  static Pattern pat_j0 = Pattern.compile(_imm);
  static Pattern pat_arith_reg = Pattern.compile(_reg + "," + _reg + "," + _reg);
  static Pattern pat_shift_c = Pattern.compile(_reg + "," + _reg + "," + _imm);
  static Pattern pat_shift_v = Pattern.compile(_reg + "," + _reg + "," + _reg);
  static Pattern pat_coproc_mov = Pattern.compile(_reg + "," + _reg);
  static Pattern pat_jr = Pattern.compile(_reg);
  static Pattern pat_jalr = Pattern.compile(_reg + "(?:," + _reg + ")?");
  static Pattern pat_regimm = Pattern.compile(_reg + "," + _imm);
  
  public static void main(String[] paramArrayOfString)
  {
    if (paramArrayOfString.length != 1)
    {
      System.err.println("usage: ProgramAssembler <mips-asm-file>");
      System.exit(1);
    }
    Listing localListing = new Listing();
    try
    {
      localListing.load(new File(paramArrayOfString[0]));
      for (Segment localSegment : localListing.seg)
      {
        for (int k = 0; k < localSegment.data.length; k++)
        {
          int m = localSegment.start_pc + k;
          int n = localListing.instr(m);
          System.out.println(toHex(m * 4, 8) + " : " + toHex(n, 8) + " : " + disassemble(n, m * 4));
        }
        System.out.println();
      }
    }
    catch (IOException localIOException)
    {
      localIOException.printStackTrace();
    }
  }
  
  private static String toHex(int paramInt1, int paramInt2)
  {
    if (paramInt2 > 8) {
      paramInt2 = 8;
    }
    String str = Long.toHexString(paramInt1 & 0xFFFFFFFF);
    if (str.length() >= paramInt2) {
      return "0x" + str;
    }
    return "0x00000000".substring(0, 2 + paramInt2 - str.length()) + str;
  }
  
  private static String readFully(File paramFile)
    throws IOException
  {
    BufferedReader localBufferedReader = new BufferedReader(new FileReader(paramFile));
    StringBuffer localStringBuffer = new StringBuffer();
    String str;
    while ((str = localBufferedReader.readLine()) != null) {
      localStringBuffer.append(str + "\n");
    }
    return localStringBuffer.toString();
  }
  
  private static ArrayList<String> splitLines(String paramString)
    throws IOException
  {
    BufferedReader localBufferedReader = new BufferedReader(new StringReader(paramString));
    ArrayList localArrayList = new ArrayList();
    String str;
    while ((str = localBufferedReader.readLine()) != null) {
      localArrayList.add(str);
    }
    return localArrayList;
  }
  
  private static ArrayList<String> normalize(ArrayList<String> paramArrayList)
  {
    ArrayList localArrayList = new ArrayList();
    for (int i = 0; i < paramArrayList.size(); i++)
    {
      String str = (String)paramArrayList.get(i);
      int j = str.indexOf('#');
      if (j == 0) {
        str = "";
      } else if (j > 0) {
        str = str.substring(0, j);
      }
      str = str.trim();
      str = pat0.matcher(str).replaceAll(" ");
      str = pat1.matcher(str).replaceAll(",");
      if (str.length() == 0) {
        localArrayList.add(null);
      } else {
        localArrayList.add(str);
      }
    }
    return localArrayList;
  }
  
  private static int parseSegmentAddress(int paramInt, String paramString)
    throws IOException
  {
    if (paramString.toLowerCase().startsWith("0x")) {
      return Integer.parseInt(paramString.substring(2), 16);
    }
    int i = paramString.charAt(0);
    if ((i >= 48) && (i <= 57)) {
      return Integer.parseInt(paramString);
    }
    throw new ParseException("Line " + (paramInt + 1) + ": illegal address '" + paramString + "' in assembly directive");
  }
  
  private static HashMap<String, Integer> pass1(ArrayList<String> paramArrayList, int paramInt, ArrayList<Integer> paramArrayList1)
    throws IOException
  {
    HashMap localHashMap = new HashMap();
    int i = paramInt;
    paramArrayList1.clear();
    ParseException localParseException1 = new ParseException();
    for (int j = 0; j < paramArrayList.size(); j++)
    {
      String str1 = (String)paramArrayList.get(j);
      if (str1 == null)
      {
        paramArrayList1.add(null);
      }
      else
      {
        int k;
        if (str1.toLowerCase().startsWith(".text"))
        {
          k = str1.indexOf(' ');
          if (k > 0) {
            try
            {
              int m = parseSegmentAddress(j, str1.substring(k + 1));
              if ((m & 0x3) != 0) {
                localParseException1.add("Line " + (j + 1) + ": mis-aligned address '" + str1.substring(k + 1) + "' in .text assembly directive");
              }
              i = m & 0xFFFFFFFC;
            }
            catch (ParseException localParseException2)
            {
              localParseException1.add(localParseException2);
            }
          }
          paramArrayList1.add(null);
        }
        else if (str1.toLowerCase().startsWith(".word"))
        {
          paramArrayList1.add(new Integer(i));
          i += 4;
        }
        else if (str1.startsWith("."))
        {
          localParseException1.add("Line " + (j + 1) + ": unrecognized assembly directive '" + str1 + "'");
        }
        else
        {
          k = str1.indexOf(':');
          if (k >= 0)
          {
            String str2 = str1.substring(0, k).trim();
            if (str2.length() == 0)
            {
              localParseException1.add("Line " + (j + 1) + ": expected label name before ':'");
            }
            else
            {
              Matcher localMatcher = pat_label.matcher(str2);
              if ((str2.equalsIgnoreCase("pc")) || (!localMatcher.matches()))
              {
                localParseException1.add("Line " + (j + 1) + ": illegal label name '" + str2 + "' before ':'");
              }
              else
              {
                localHashMap.put(str2, new Integer(i));
                if (k < str1.length() - 1)
                {
                  str1 = str1.substring(k + 1).trim();
                  paramArrayList.set(j, str1);
                  paramArrayList1.add(new Integer(i));
                  i += 4;
                }
                else
                {
                  paramArrayList1.add(null);
                  paramArrayList.set(j, null);
                }
              }
            }
          }
          else
          {
            paramArrayList1.add(new Integer(i));
            i += 4;
          }
        }
      }
    }
    if (localParseException1.getCount() > 0) {
      throw localParseException1;
    }
    return localHashMap;
  }
  
  private static int resolve(int paramInt1, String paramString, int paramInt2, HashMap<String, Integer> paramHashMap, Type paramType, int paramInt3)
    throws IOException
  {
    int i = paramType == Type.SIGNED_RELATIVE ? paramInt2 + 4 : 0;
    long l1 = paramType == Type.UNSIGNED_ABSOLUTE ? 0L : -1L << paramInt3 - 1;
    long l2 = paramType == Type.UNSIGNED_ABSOLUTE ? (1L << paramInt3) - 1L : (1L << paramInt3 - 1) - 1L;
    int j = (int)(1L << paramInt3) - 1;
    try
    {
      if (paramString.length() == 0) {
        throw new NumberFormatException();
      }
      int k = paramString.charAt(0);
      long l3;
      if (paramString.equalsIgnoreCase("pc"))
      {
        l3 = (paramInt2 & 0xFFFFFFFF) - i;
      }
      else
      {
        if (paramString.toLowerCase().startsWith("0x"))
        {
          l3 = Long.parseLong(paramString.substring(2), 16);
          if ((l3 & j) != l3) {
            throw new ParseException("Line " + (paramInt1 + 1) + ": overflow in " + paramType + " '" + paramString + "' (" + paramInt3 + " bits maximum)");
          }
          return (int)(l3 & j);
        }
        if ((k == 45) || ((k >= 48) && (k <= 57)))
        {
          l3 = Long.parseLong(paramString);
        }
        else
        {
          Integer localInteger = (Integer)paramHashMap.get(paramString);
          if (localInteger == null) {
            throw new ParseException("Line " + (paramInt1 + 1) + ": expecting " + paramType + ", but no such label or number '" + paramString + "'");
          }
          l3 = (localInteger.intValue() & 0xFFFFFFFF) - i;
          paramString = paramString + " (" + l3 + ")";
        }
      }
      if (paramType == Type.ANY_ABSOLUTE)
      {
        if ((l3 & j) != l3) {
          throw new ParseException("Line " + (paramInt1 + 1) + ": overflow in " + paramType + " '" + paramString + "' (" + paramInt3 + " bits maximum)");
        }
      }
      else if ((l3 < l1) || (l3 > l2)) {
        throw new ParseException("Line " + (paramInt1 + 1) + ": overflow in " + paramType + " '" + paramString + "' : allowed range is " + l1 + " (" + toHex((int)l1 & j, 1) + ") to " + l2 + " (" + toHex((int)l2 & j, 1) + ")");
      }
      return (int)(l3 & j);
    }
    catch (NumberFormatException localNumberFormatException)
    {
      throw new ParseException("Line " + (paramInt1 + 1) + ": invalid " + paramType + " '" + paramString + "'");
    }
  }
  
  private static int reg(String paramString)
    throws NumberFormatException
  {
    switch (paramString.charAt(0))
    {
    case 'z': 
      return 0;
    case 'a': 
      if (paramString.equals("at")) {
        return 1;
      }
      return 4 + Integer.parseInt(paramString.substring(1));
    case 'v': 
      return 2 + Integer.parseInt(paramString.substring(1));
    case 't': 
      int i = Integer.parseInt(paramString.substring(1));
      if (i <= 7) {
        return 8 + i;
      }
      return 24 + (i - 8);
    case 's': 
      if (paramString.equals("sp")) {
        return 29;
      }
      return 16 + Integer.parseInt(paramString.substring(1));
    case 'k': 
      return 26 + Integer.parseInt(paramString.substring(1));
    case 'g': 
      return 28;
    case 'f': 
      return 30;
    case 'r': 
      return 31;
    }
    return Integer.parseInt(paramString);
  }
  
  private static Segment[] pass2(ArrayList<String> paramArrayList, int paramInt, HashMap<String, Integer> paramHashMap)
    throws IOException
  {
    ParseException localParseException1 = new ParseException();
    int i = paramInt;
    int j = 0;
    ArrayList localArrayList = new ArrayList();
    int k = paramInt >>> 2;
    for (int m = 0; m < paramArrayList.size(); m++)
    {
      String str1 = (String)paramArrayList.get(m);
      if (str1 != null) {
        if (str1.toLowerCase().startsWith(".text "))
        {
          if (j > 0) {
            localArrayList.add(new Segment(k, new int[j]));
          }
          j = 0;
          k = parseSegmentAddress(m, str1.substring(str1.indexOf(' ') + 1)) >>> 2;
        }
        else
        {
          j++;
        }
      }
    }
    if (j > 0) {
      localArrayList.add(new Segment(k, new int[j]));
    }
    Segment[] arrayOfSegment = new Segment[localArrayList.size()];
    if (arrayOfSegment.length == 0) {
      return arrayOfSegment;
    }
    for (int n = 0; n < arrayOfSegment.length; n++)
    {
      arrayOfSegment[n] = ((Segment)localArrayList.get(n));
      for (i1 = 0; i1 < n; i1++) {
        if ((arrayOfSegment[n].start_pc < arrayOfSegment[i1].start_pc + arrayOfSegment[i1].data.length) && (arrayOfSegment[i1].start_pc < arrayOfSegment[n].start_pc + arrayOfSegment[n].data.length)) {
          localParseException1.add("Assembly segment at " + toHex(arrayOfSegment[n].start_pc * 4, 8) + ".." + toHex((arrayOfSegment[n].start_pc + arrayOfSegment[n].data.length) * 4, 8) + " overlaps with segment at " + toHex(arrayOfSegment[i1].start_pc * 4, 8) + ".." + toHex((arrayOfSegment[i1].start_pc + arrayOfSegment[i1].data.length) * 4, 8));
        }
      }
    }
    n = 0;
    j = 0;
    for (int i1 = 0; i1 < paramArrayList.size(); i1++)
    {
      String str2 = (String)paramArrayList.get(i1);
      if (str2 != null)
      {
        int i2 = str2.indexOf(' ');
        String str3 = i2 >= 0 ? str2.substring(0, i2) : str2;
        String str4 = i2 >= 0 ? str2.substring(i2 + 1) : "";
        if (str3.equalsIgnoreCase(".text"))
        {
          n = -1;
          k = parseSegmentAddress(i1, str2.substring(str2.indexOf(' ') + 1)) >>> 2;
          i = k << 2;
          j = 0;
          for (int i3 = 0; i3 < arrayOfSegment.length; i3++) {
            if (arrayOfSegment[i3].start_pc == k)
            {
              n = i3;
              break;
            }
          }
          if (n < 0) {
            localParseException1.add("Line " + (i1 + 1) + ": internal error: bad segment");
          }
        }
        else
        {
          Command localCommand = (Command)cmds.get(str3.toLowerCase());
          if (localCommand == null)
          {
            localParseException1.add("Line " + (i1 + 1) + ": unrecognized instruction: '" + str3 + "'");
          }
          else if (n >= 0)
          {
            try
            {
              arrayOfSegment[n].data[(j++)] = localCommand.encode(i1, i, str4, paramHashMap);
            }
            catch (ParseException localParseException2)
            {
              localParseException1.add(localParseException2);
            }
            i += 4;
          }
        }
      }
    }
    if (localParseException1.getCount() > 0) {
      throw localParseException1;
    }
    return arrayOfSegment;
  }
  
  private static Segment[] assemble(ArrayList<String> paramArrayList, int paramInt, ArrayList<Integer> paramArrayList1)
    throws IOException
  {
    ArrayList localArrayList = normalize(paramArrayList);
    HashMap localHashMap = pass1(localArrayList, paramInt, paramArrayList1);
    return pass2(localArrayList, paramInt, localHashMap);
  }
  
  private static String disassemble(int[] paramArrayOfInt, int paramInt)
    throws IOException
  {
    StringBuffer localStringBuffer = new StringBuffer();
    for (int i = 0; i < paramArrayOfInt.length; i++)
    {
      int j = paramArrayOfInt[i];
      int k = j >> 26 & 0x3F;
      int m;
      Command localCommand;
      if (k == 0)
      {
        m = j & 0x3F;
        localCommand = (Command)fcodes.get(new Integer(m));
      }
      else if (k == 1)
      {
        m = j >> 16 & 0x1F;
        localCommand = (Command)socodes.get(new Integer(m));
      }
      else if (k == 16)
      {
        m = j >> 21 & 0x3F;
        localCommand = (Command)fcodes.get(new Integer(m));
      }
      else
      {
        localCommand = (Command)opcodes.get(new Integer(k));
      }
      if (localCommand == null) {
        throw new ParseException("Instruction " + (i + 1) + " unrecognized: " + toHex(j, 8));
      }
      localStringBuffer.append(localCommand.decode(paramInt + 4 * i, j) + "\n");
    }
    return localStringBuffer.toString();
  }
  
  static String disassemble(int paramInt1, int paramInt2)
  {
    int i = paramInt1 >> 26 & 0x3F;
    int j;
    Command localCommand;
    if (i == 0)
    {
      j = paramInt1 & 0x3F;
      localCommand = (Command)fcodes.get(new Integer(j));
    }
    else if (i == 1)
    {
      j = paramInt1 >> 16 & 0x1F;
      localCommand = (Command)socodes.get(new Integer(j));
    }
    else if (i == 16)
    {
      j = paramInt1 >> 21 & 0x3F;
      localCommand = (Command)fcodes.get(new Integer(j));
    }
    else
    {
      localCommand = (Command)opcodes.get(new Integer(i));
    }
    if (localCommand == null) {
      localCommand = (Command)opcodes.get(new Integer(-1));
    }
    return localCommand.decode(paramInt2, paramInt1);
  }
  
  static
  {
    new Word(".word", -1);
    new Nop("nop", 0);
    new Syscall("syscall", 16);
    new Eret("eret", 8);
    new J("j", 2);
    new J("jal", 3);
    new Br("beq", 4);
    new Br("bne", 5);
    new Bz("blez", 6);
    new Bz("bgtz", 7);
    new RegImm("bltz", 0);
    new RegImm("bgez", 1);
    new ArithImm("addiu", 9, true);
    new ArithImm("slti", 10, true);
    new ArithImm("sltiu", 11, true);
    new ArithImm("andi", 12, false);
    new ArithImm("ori", 13, false);
    new ArithImm("xori", 14, false);
    new Lui("lui", 15);
    new Mem("lw", 35);
    new Mem("lb", 32);
    new Mem("lbu", 36);
    new Mem("sw", 43);
    new Mem("sb", 40);
    new ArithReg("addu", 0, 33);
    new ArithReg("subu", 0, 35);
    new ArithReg("and", 0, 36);
    new ArithReg("or", 0, 37);
    new ArithReg("xor", 0, 38);
    new ArithReg("nor", 0, 39);
    new ArithReg("slt", 0, 42);
    new ArithReg("sltu", 0, 43);
    new ArithReg("movz", 0, 10);
    new ArithReg("movn", 0, 11);
    new ShiftConstant("sll", 0, 0);
    new ShiftConstant("srl", 0, 2);
    new ShiftConstant("sra", 0, 3);
    new ShiftVariable("sllv", 0, 4);
    new ShiftVariable("srlv", 0, 6);
    new ShiftVariable("srav", 0, 7);
    new CoprocMove("mfc0", 16, 1);
    new CoprocMove("mtc0", 16, 5);
    new Jr("jr", 0, 8);
    new Jalr("jalr", 0, 9);
  }
  
  private static class RegImm
    extends ProgramAssembler.Command
  {
    int subop;
    
    RegImm(String paramString, int paramInt)
    {
      super(1);
      this.subop = paramInt;
      ProgramAssembler.socodes.put(new Integer(paramInt), this);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_regimm.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects $S, offset or label");
      }
      int i = ProgramAssembler.resolve(paramInt1, localMatcher.group(2), paramInt2, paramHashMap, ProgramAssembler.Type.SIGNED_RELATIVE, 18);
      if ((i & 0x3) != 0) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": mis-aligned offset in '" + this.name + "'");
      }
      try
      {
        int j = ProgramAssembler.reg(localMatcher.group(1));
        int k = i >> 2 & 0xFFFF;
        if ((this.subop & 0x1F) != this.subop) {
          throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": invalid sub-operation: $" + this.subop);
        }
        if ((j & 0x1F) != j) {
          throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": invalid source register: $" + j);
        }
        return 0x4000000 | j << 21 | this.subop << 16 | k;
      }
      catch (NumberFormatException localNumberFormatException)
      {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": invalid arguments to '" + this.name + "': " + localNumberFormatException.getMessage());
      }
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name + " " + rS(paramInt2) + ", " + sImm(paramInt2 << 2);
    }
    
    String rS(int paramInt)
    {
      return "$" + (paramInt >> 21 & 0x1F);
    }
    
    String sImm(int paramInt)
    {
      return ProgramAssembler.toHex(paramInt & 0xFFFF, 4);
    }
  }
  
  private static class Jalr
    extends ProgramAssembler.RType
  {
    Jalr(String paramString, int paramInt1, int paramInt2)
    {
      super(paramInt1, paramInt2);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_jalr.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects $S");
      }
      int i = localMatcher.group(2) != null ? 1 : 0;
      String str1 = i != 0 ? localMatcher.group(1) : "31";
      String str2 = localMatcher.group(i != 0 ? 2 : 1);
      return encode(str1, str2, "0", 0, paramInt1);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      if ("31".equals(rD(paramInt2))) {
        return this.name + " " + rS(paramInt2);
      }
      return this.name + " " + rD(paramInt2) + ", " + rS(paramInt2);
    }
  }
  
  private static class Jr
    extends ProgramAssembler.RType
  {
    Jr(String paramString, int paramInt1, int paramInt2)
    {
      super(paramInt1, paramInt2);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_jr.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects $S");
      }
      return encode("0", localMatcher.group(1), "0", 0, paramInt1);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name + " " + rS(paramInt2);
    }
  }
  
  private static class CoprocMove
    extends ProgramAssembler.CopType
  {
    CoprocMove(String paramString, int paramInt1, int paramInt2)
    {
      super(paramInt1, paramInt2);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_coproc_mov.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects $T, $D");
      }
      return encode(localMatcher.group(2), localMatcher.group(1), 0, paramInt1);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name + " " + rT(paramInt2) + ", " + rD(paramInt2);
    }
  }
  
  private static class ShiftVariable
    extends ProgramAssembler.RType
  {
    ShiftVariable(String paramString, int paramInt1, int paramInt2)
    {
      super(paramInt1, paramInt2);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_shift_v.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects $D, $T, $S");
      }
      return encode(localMatcher.group(1), localMatcher.group(3), localMatcher.group(2), 0, paramInt1);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name + " " + rD(paramInt2) + ", " + rT(paramInt2) + ", " + rS(paramInt2);
    }
  }
  
  private static class ShiftConstant
    extends ProgramAssembler.RType
  {
    ShiftConstant(String paramString, int paramInt1, int paramInt2)
    {
      super(paramInt1, paramInt2);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_shift_c.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects $D, $T, sa");
      }
      int i = ProgramAssembler.resolve(paramInt1, localMatcher.group(3), paramInt2, paramHashMap, ProgramAssembler.Type.UNSIGNED_ABSOLUTE, 5);
      return encode(localMatcher.group(1), "0", localMatcher.group(2), i, paramInt1);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name + " " + rD(paramInt2) + ", " + rT(paramInt2) + ", " + sSa(paramInt2);
    }
  }
  
  private static class ArithReg
    extends ProgramAssembler.RType
  {
    ArithReg(String paramString, int paramInt1, int paramInt2)
    {
      super(paramInt1, paramInt2);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_arith_reg.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects $D, $S, $T");
      }
      return encode(localMatcher.group(1), localMatcher.group(2), localMatcher.group(3), 0, paramInt1);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name + " " + rD(paramInt2) + ", " + rS(paramInt2) + ", " + rT(paramInt2);
    }
  }
  
  private static abstract class CopType
    extends ProgramAssembler.Command
  {
    int f;
    
    CopType(String paramString, int paramInt1, int paramInt2)
    {
      super(0);
      this.f = paramInt2;
      ProgramAssembler.fcodes.put(new Integer(paramInt2), this);
    }
    
    int encode(String paramString1, String paramString2, int paramInt1, int paramInt2)
      throws IOException
    {
      try
      {
        int i = ProgramAssembler.reg(paramString1);
        int j = ProgramAssembler.reg(paramString2);
        if ((i & 0x1F) != i) {
          throw new ProgramAssembler.ParseException("Line " + (paramInt2 + 1) + ": invalid destination register: $" + i);
        }
        if ((j & 0x1F) != j) {
          throw new ProgramAssembler.ParseException("Line " + (paramInt2 + 1) + ": invalid source1 register: $" + j);
        }
        if ((paramInt1 & 0x1F) != paramInt1) {
          throw new ProgramAssembler.ParseException("Line " + (paramInt2 + 1) + ": invalid shift amount: " + paramInt1);
        }
        return this.opcode << 26 | paramInt1 << 21 | j << 16 | i << 11 | this.f;
      }
      catch (NumberFormatException localNumberFormatException)
      {
        throw new ProgramAssembler.ParseException("Line " + (paramInt2 + 1) + ": invalid arguments to '" + this.name + "': " + localNumberFormatException.getMessage());
      }
    }
    
    String rD(int paramInt)
    {
      return "$" + (paramInt >> 11 & 0x1F);
    }
    
    String rT(int paramInt)
    {
      return "$" + (paramInt >> 16 & 0x1F);
    }
    
    String sSa(int paramInt)
    {
      return "" + (paramInt >> 6 & 0x1F);
    }
  }
  
  private static abstract class RType
    extends ProgramAssembler.Command
  {
    int f;
    
    RType(String paramString, int paramInt1, int paramInt2)
    {
      super(0);
      this.f = paramInt2;
      ProgramAssembler.fcodes.put(new Integer(paramInt2), this);
    }
    
    int encode(String paramString1, String paramString2, String paramString3, int paramInt1, int paramInt2)
      throws IOException
    {
      try
      {
        int i = ProgramAssembler.reg(paramString1);
        int j = ProgramAssembler.reg(paramString2);
        int k = ProgramAssembler.reg(paramString3);
        if ((i & 0x1F) != i) {
          throw new ProgramAssembler.ParseException("Line " + (paramInt2 + 1) + ": invalid destination register: $" + i);
        }
        if ((j & 0x1F) != j) {
          throw new ProgramAssembler.ParseException("Line " + (paramInt2 + 1) + ": invalid source1 register: $" + j);
        }
        if ((k & 0x1F) != k) {
          throw new ProgramAssembler.ParseException("Line " + (paramInt2 + 1) + ": invalid source2 register: $" + k);
        }
        if ((paramInt1 & 0x1F) != paramInt1) {
          throw new ProgramAssembler.ParseException("Line " + (paramInt2 + 1) + ": invalid shift amount: " + paramInt1);
        }
        return this.opcode << 26 | j << 21 | k << 16 | i << 11 | paramInt1 << 6 | this.f;
      }
      catch (NumberFormatException localNumberFormatException)
      {
        throw new ProgramAssembler.ParseException("Line " + (paramInt2 + 1) + ": invalid arguments to '" + this.name + "': " + localNumberFormatException.getMessage());
      }
    }
    
    String rD(int paramInt)
    {
      return "$" + (paramInt >> 11 & 0x1F);
    }
    
    String rS(int paramInt)
    {
      return "$" + (paramInt >> 21 & 0x1F);
    }
    
    String rT(int paramInt)
    {
      return "$" + (paramInt >> 16 & 0x1F);
    }
    
    String sSa(int paramInt)
    {
      return "" + (paramInt >> 6 & 0x1F);
    }
  }
  
  private static class J
    extends ProgramAssembler.Command
  {
    J(String paramString, int paramInt)
    {
      super(paramInt);
      ProgramAssembler.opcodes.put(new Integer(paramInt), this);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_j0.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects address or label");
      }
      int i = ProgramAssembler.resolve(paramInt1, localMatcher.group(1), paramInt2, paramHashMap, ProgramAssembler.Type.UNSIGNED_ABSOLUTE, 32);
      if ((i & 0x3) != 0) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": mis-aligned address in '" + this.name + "'");
      }
      if ((i & 0xF0000000) != (paramInt2 + 4 & 0xF0000000)) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": overflow in address in '" + this.name + "': can't jump from " + ProgramAssembler.toHex(paramInt2, 8) + " to " + ProgramAssembler.toHex(i, 8));
      }
      return this.opcode << 26 | i >> 2 & 0x3FFFFFF;
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name + " " + ProgramAssembler.toHex(paramInt1 + 4 & 0xF0000000 | (paramInt2 & 0x3FFFFFF) << 2, 8);
    }
  }
  
  private static class Bz
    extends ProgramAssembler.IType
  {
    Bz(String paramString, int paramInt)
    {
      super(paramInt);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_bz.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects $S, offset or label");
      }
      int i = ProgramAssembler.resolve(paramInt1, localMatcher.group(2), paramInt2, paramHashMap, ProgramAssembler.Type.SIGNED_RELATIVE, 18);
      if ((i & 0x3) != 0) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": mis-aligned offset in '" + this.name + "'");
      }
      return encode("0", localMatcher.group(1), i >> 2, paramInt1);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name + " " + rS(paramInt2) + ", " + sImm(paramInt2 << 2);
    }
  }
  
  private static class Br
    extends ProgramAssembler.IType
  {
    Br(String paramString, int paramInt)
    {
      super(paramInt);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_br.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects $S, $T, offset or label");
      }
      int i = ProgramAssembler.resolve(paramInt1, localMatcher.group(3), paramInt2, paramHashMap, ProgramAssembler.Type.SIGNED_RELATIVE, 18);
      if ((i & 0x3) != 0) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": mis-aligned offset in '" + this.name + "'");
      }
      return encode(localMatcher.group(2), localMatcher.group(1), i >> 2, paramInt1);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name + " " + rS(paramInt2) + ", " + rD(paramInt2) + ", " + sImm(paramInt2 << 2);
    }
  }
  
  private static class Mem
    extends ProgramAssembler.IType
  {
    Mem(String paramString, int paramInt)
    {
      super(paramInt);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_mem.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects $D, signed_imm($S)");
      }
      int i = ProgramAssembler.resolve(paramInt1, localMatcher.group(2), paramInt2, paramHashMap, ProgramAssembler.Type.SIGNED_ABSOLUTE, 16);
      return encode(localMatcher.group(1), localMatcher.group(3), i, paramInt1);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name + " " + rD(paramInt2) + ", " + sImm(paramInt2) + "(" + rS(paramInt2) + ")";
    }
  }
  
  private static class Lui
    extends ProgramAssembler.IType
  {
    Lui(String paramString, int paramInt)
    {
      super(paramInt);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_lui.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects $D, imm");
      }
      int i = ProgramAssembler.resolve(paramInt1, localMatcher.group(2), paramInt2, paramHashMap, ProgramAssembler.Type.ANY_ABSOLUTE, 16);
      return encode(localMatcher.group(1), "0", i, paramInt1);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name + " " + rD(paramInt2) + ", " + sImm(paramInt2);
    }
  }
  
  private static class ArithImm
    extends ProgramAssembler.IType
  {
    ProgramAssembler.Type itype = paramBoolean ? ProgramAssembler.Type.SIGNED_ABSOLUTE : ProgramAssembler.Type.UNSIGNED_ABSOLUTE;
    
    ArithImm(String paramString, int paramInt, boolean paramBoolean)
    {
      super(paramInt);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_arith_imm.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects $D, $S, " + this.itype);
      }
      int i = ProgramAssembler.resolve(paramInt1, localMatcher.group(3), paramInt2, paramHashMap, this.itype, 16);
      return encode(localMatcher.group(1), localMatcher.group(2), i, paramInt1);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name + " " + rD(paramInt2) + ", " + rS(paramInt2) + ", " + sImm(paramInt2);
    }
  }
  
  private static abstract class IType
    extends ProgramAssembler.Command
  {
    IType(String paramString, int paramInt)
    {
      super(paramInt);
      ProgramAssembler.opcodes.put(new Integer(paramInt), this);
    }
    
    int encode(String paramString1, String paramString2, int paramInt1, int paramInt2)
      throws IOException
    {
      try
      {
        int i = ProgramAssembler.reg(paramString1);
        int j = ProgramAssembler.reg(paramString2);
        paramInt1 &= 0xFFFF;
        if ((i & 0x1F) != i) {
          throw new ProgramAssembler.ParseException("Line " + (paramInt2 + 1) + ": invalid destination register: $" + i);
        }
        if ((j & 0x1F) != j) {
          throw new ProgramAssembler.ParseException("Line " + (paramInt2 + 1) + ": invalid source register: $" + j);
        }
        return this.opcode << 26 | j << 21 | i << 16 | paramInt1;
      }
      catch (NumberFormatException localNumberFormatException)
      {
        throw new ProgramAssembler.ParseException("Line " + (paramInt2 + 1) + ": invalid arguments to '" + this.name + "': " + localNumberFormatException.getMessage());
      }
    }
    
    String rD(int paramInt)
    {
      return "$" + (paramInt >> 16 & 0x1F);
    }
    
    String rS(int paramInt)
    {
      return "$" + (paramInt >> 21 & 0x1F);
    }
    
    String sImm(int paramInt)
    {
      return ProgramAssembler.toHex(paramInt & 0xFFFF, 4);
    }
  }
  
  private static class Word
    extends ProgramAssembler.Command
  {
    Word(String paramString, int paramInt)
    {
      super(paramInt);
      ProgramAssembler.opcodes.put(new Integer(paramInt), this);
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      Matcher localMatcher = ProgramAssembler.pat_word.matcher(paramString);
      if (!localMatcher.matches()) {
        throw new ProgramAssembler.ParseException("Line " + (paramInt1 + 1) + ": '" + this.name + "' expects integer argument");
      }
      int i = ProgramAssembler.resolve(paramInt1, localMatcher.group(1), paramInt2, paramHashMap, ProgramAssembler.Type.ANY_ABSOLUTE, 32);
      return i;
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name + " " + ProgramAssembler.toHex(paramInt2, 8);
    }
  }
  
  private static class Eret
    extends ProgramAssembler.Command
  {
    Eret(String paramString, int paramInt)
    {
      super(paramInt);
      ProgramAssembler.opcodes.put(new Integer(paramInt), this);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name;
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      return 570425350;
    }
  }
  
  private static class Syscall
    extends ProgramAssembler.Command
  {
    Syscall(String paramString, int paramInt)
    {
      super(paramInt);
      ProgramAssembler.opcodes.put(new Integer(paramInt), this);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name;
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      return 6;
    }
  }
  
  private static class Nop
    extends ProgramAssembler.Command
  {
    Nop(String paramString, int paramInt)
    {
      super(paramInt);
    }
    
    String decode(int paramInt1, int paramInt2)
    {
      return this.name;
    }
    
    int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException
    {
      return 0;
    }
  }
  
  private static abstract class Command
  {
    String name;
    int opcode;
    
    Command(String paramString, int paramInt)
    {
      this.name = paramString;
      this.opcode = paramInt;
      ProgramAssembler.cmds.put(paramString, this);
    }
    
    abstract String decode(int paramInt1, int paramInt2);
    
    abstract int encode(int paramInt1, int paramInt2, String paramString, HashMap<String, Integer> paramHashMap)
      throws IOException;
  }
  
  private static enum Type
  {
    SIGNED_RELATIVE,  SIGNED_ABSOLUTE,  UNSIGNED_ABSOLUTE,  ANY_ABSOLUTE;
    
    private Type() {}
  }
  
  static class ParseException
    extends IOException
  {
    private static final long serialVersionUID = 4648870901015801834L;
    StringBuffer msg = new StringBuffer();
    int count = 0;
    
    public ParseException() {}
    
    public ParseException(String paramString)
    {
      this();
      add(paramString);
    }
    
    public void add(String paramString)
    {
      this.msg.append("\n");
      this.msg.append(paramString);
      this.count += 1;
    }
    
    public void add(ParseException paramParseException)
    {
      this.msg.append(paramParseException.msg.toString());
      this.count += paramParseException.getCount();
    }
    
    public String getMessage()
    {
      return "Assembling MIPS instructions: " + this.count + (this.count == 1 ? " error:" : " errors:") + this.msg.toString();
    }
    
    public int getCount()
    {
      return this.count;
    }
  }
  
  static class Listing
    implements Cloneable
  {
    private String src = "";
    private ProgramAssembler.Segment[] seg = new ProgramAssembler.Segment[0];
    private ProgramState state;
    private ArrayList<String> src_lines = new ArrayList();
    private ArrayList<Integer> addr_map = new ArrayList();
    
    public Listing() {}
    
    public Listing(String paramString)
      throws IOException
    {
      setSource(paramString);
    }
    
    public void setListener(ProgramState paramProgramState)
    {
      this.state = paramProgramState;
    }
    
    public void load(File paramFile)
      throws IOException
    {
      String str = ProgramAssembler.readFully(paramFile);
      setSource(str);
    }
    
    public ProgramState getState()
    {
      return this.state;
    }
    
    public String getSource()
    {
      return this.src;
    }
    
    public int getLineCount()
    {
      return this.src_lines.size();
    }
    
    public String getLine(int paramInt)
    {
      return (String)this.src_lines.get(paramInt);
    }
    
    public int getAddressOf(int paramInt)
    {
      Integer localInteger = (Integer)this.addr_map.get(paramInt);
      if (localInteger == null) {
        return -1;
      }
      return localInteger.intValue();
    }
    
    public void setSource(String paramString)
      throws IOException
    {
      ArrayList localArrayList1 = ProgramAssembler.splitLines(paramString);
      ArrayList localArrayList2 = new ArrayList();
      this.seg = ProgramAssembler.assemble(localArrayList1, 0, localArrayList2);
      this.src = paramString;
      this.addr_map = localArrayList2;
      this.src_lines = localArrayList1;
    }
    
    public boolean isEmpty()
    {
      return this.seg.length == 0;
    }
    
    int instr(int paramInt)
    {
      ProgramAssembler.Segment localSegment = segmentOf(paramInt);
      if (localSegment != null) {
        return localSegment.data[(paramInt - localSegment.start_pc)];
      }
      return 0;
    }
    
    ProgramAssembler.Segment segmentOf(int paramInt)
    {
      for (int i = 0; i < this.seg.length; i++) {
        if ((paramInt >= this.seg[i].start_pc) && (paramInt < this.seg[i].start_pc + this.seg[i].data.length)) {
          return this.seg[i];
        }
      }
      return null;
    }
    
    public Listing clone()
    {
      try
      {
        return (Listing)super.clone();
      }
      catch (CloneNotSupportedException localCloneNotSupportedException) {}
      return null;
    }
  }
  
  private static class Segment
    implements Cloneable
  {
    public int start_pc;
    public int[] data;
    
    public Segment(int paramInt, int[] paramArrayOfInt)
    {
      this.start_pc = paramInt;
      this.data = paramArrayOfInt;
    }
  }
}
